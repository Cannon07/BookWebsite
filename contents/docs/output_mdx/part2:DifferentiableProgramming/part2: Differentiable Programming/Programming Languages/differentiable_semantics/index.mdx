# Semantics for Differentiable Programs \{#chap:grammar\}

------------------------------------------------------------------------

\
**Prerequisites:**
[\[chap:autodiff\]](#chap:autodiff)\{reference-type="ref+label"
reference="chap:autodiff"\},
[\[chap:hindley_milner\]](#chap:hindley_milner)\{reference-type="ref+label"
reference="chap:hindley_milner"\}\
**Difficulty Level:** \*\*\*\

------------------------------------------------------------------------

While we have studied semantics for simply typed and polymoriphically
typed languages in the last few chapters, we have not yet seen how to
model the semantics of a differentiable programming language. In this
chapter, we present $\lambda_S$, a system of semantics for a
differentiable programming language.

## Physika is a Functional Language

Throughout this book, we have given Physika code in what looks like
imperative style. Most numerical programming and deep learning texts
provide examples in imperative code, so allowing Physika to follow the
same style simplifed exposition considerably. However, implementing
automatic differentiation in an imperative language causes considerable
additional difficulty since the values of variables can change during
execution.

For this reason, underneath the hood, Physika is actually a fully
functional programming language. Let's work through a code example.
Consider the imperative code

    sum = 0
    for i in 100:
      sum += i

Physika converts this loop into code that looks roughly like

``` \{.python language="python"\}
sum = 0
sum0 = sum + 0
sum1 = sum0 + 1
sum2 = sum1 + 2
...
```

That is, the loop is fully unrolled and each update to a variable
actually creates an entirely new variable.

As another example, consider

``` \{.python language="python"\}
setting = 3
def g():
  setting += 1
  setting
print(g())
```

This code is unrolled into

``` \{.python language="python"\}
setting = 3
setting = setting + 1
print(setting)
```

This unrolling operation allows for every Physika control structure to
be unrolled into a simple trace that can be automatically
differentiated.

## Converting to Traces

The core idea of how we assign semantics to Physika programs is that we
simplify Physika programs into linear traces. The idea is that a complex
program which may involve control structures is transformed into a
simple list of instructions. This simpler architecture can then be
directly backpropagated through in order to generate the needed
gradients. Note that such a simplification tranform is always possible
since any program must at the end of the transform down to simple
instructions that can be run on assembly.

We define a sub-language, the Physika trace language that is a
restricted subset of Physika that has no conditional statements, no
function definitions, no function calls, and no reverse mode
differentiation. We define a series of transformations that transform an
arbitrary Physika program into a trace language call. After the
simplification transformations, Physika will be reduced to a core
language that satisfies the following grammar.

$$\begin\{aligned\}
    C ::= & x  \\
    &| r \in \mathbb\{R\} \\
    &| C + D \\
    &| (C, D) \\
    &| C[i]   \\
    &| C(D)
\end\{aligned\}$$

## Denotational Semantics

Denotational semantics provide a mechanism to turn a Physika program
into a function on a suitable mathematical space.

$$\begin\{aligned\}
    \llbracket R \rrbracket &= \mathbb\{R\} \\
    \llbracket T \times U \rrbracket &= \llbracket T \rrbracket \times \llbracket U \rrbracket \\
    \llbracket M + N \rrbracket &= \llbracket M \rrbracket + \llbracket N \rrbracket \\
    \llbracket (M, N) \rrbracket &= (\llbracket M \rrbracket, \llbracket N \rrbracket)
\end\{aligned\}$$

The above fragment provides a partial listing of the denotational
semantics for Physika programs that demonstrates how arithmetic
operations can be mapped to corresponding operations on the real
numbers.
