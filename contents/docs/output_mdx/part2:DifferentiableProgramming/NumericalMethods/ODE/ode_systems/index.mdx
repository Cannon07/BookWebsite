# Systems of Ordinary Differential Equations \{#chap:systems_ode\}

------------------------------------------------------------------------

\
**Prerequisites:**
[\[chap:calculus\]](#chap:calculus)\{reference-type="ref+label"
reference="chap:calculus"\}\
**Difficulty Level:** \*\*\

------------------------------------------------------------------------

In this chapter we will learn how to implement Euler's method and
Runge-Kutta's fourth order method for solving a general system of
ordinary differential equations. We study the specific examples of the
spring-mass damper system and the Lotka-Volterra system and solve these
systems with Euler's method and Runge-Kutta's fourth order method.

In this chapter, we will look at solving a system of ODEs using the
Euler's and Runge-Kutta methods. In the previous lectures, we have
solved a single ODE using either Euler or Runge-Kutta methods. However,
in practice, many problems in engineering and science require the
solution of a system of simultaneous ordinary differential equations.
Here, we will look at extending our knowledge on solving single ODEs to
this generalized system of ODEs.

## Systems of Equations

Many practical problems in engineering and science require the solution
of a system of simultaneous ordinary differential equations rather than
a single equation. Such systems may be represented generally as
$$\begin\{aligned\}
\frac\{\partial y_1\}\{\partial t\} = f_1(t,y_1,y_2,\dots,y_n)\\
\frac\{\partial y_2\}\{\partial t\} = f_2(t,y_1,y_2,\dots,y_n)\\
\vdots \\
\frac\{\partial y_n\}\{\partial t\} = f_n(t,y_1,y_2,\dots,y_n)
\end\{aligned\}$$

::: marginfigure
![image](figures/part1b/ode_systems/rk4_0.png)\{width="2.5in"\}
:::

The solution of such a system requires that $n$ initial conditions be
known at the starting value of $t$. All the methods discussed earlier
for single equations can be extended to systems of ODEs. Engineering
applications can involve thousands of simultaneous equations. In each
case, the procedure for solving a system of equations simply involves
applying the one-step technique for every equation at each step before
proceeding to the next step.

Note that any of the higher-order RK methods discussed earlier can also
be applied to systems of equations. However, care must be taken in
determining the slopes. These slopes can be observed for the classical
fourth order method from the figure. That is, we first develop slopes
for all variables at the initial value. These slopes (a set of $k1$'s)
are then used to make predictions of the dependent variable at the
midpoint of the interval. These midpoint values are in turn used to
compute a set of slopes at the midpoint (the $k2$'s). These new slopes
are then taken back to the starting point to make another set of
midpoint predictions that lead to new slope predictions at the midpoint
(the k3's). These are then employed to make predictions at the end of
the interval that are used to develop slopes at the end of the interval
(the $k4$'s). Finally, the $k$'s are combined into a set of increment
functions that are brought back to the beginning to make the final
predictions. The following example illustrates the approaches of Euler
and Runge-Kutta methods.

## A Mass-Damped Spring System

A spring-mass damper system's amplitude is given by the following second
order differential equation

$$m\frac\{d^2x\}\{dt^2\} + c\frac\{dx\}\{dt\} + kx = F(t)$$

The above equation can be written as two first order ODEs by using two
state variables namely $$\begin\{aligned\}
x_1 &= x\\ 
x_2 &= \frac\{dx\}\{dt\}
\end\{aligned\}$$ By doing so, the second order ODE can be re-written as
$$\begin\{aligned\}
    \begin\{split\}
        \frac\{dx_1\}\{dt\} &= x_2\\
        \frac\{dx_2\}\{dt\} &=  -\frac\{k\}\{m\}x_1 - -\frac\{c\}\{m\}x_2 + \frac\{F\}\{m\}
    \end\{split\}
\end\{aligned\}$$

Now, the problem is reduced to solving a system of first order ODEs.
Let's solve the above dynamical system to determine the state-variables
at every time-step first using Euler's method

::: marginfigure
![image](figures/part1b/ode_systems/Spring mass damper.png)\{width="2.75in"\}
:::

``` \{.python language="python"\}
def mass_damped_system(m : $\mathbb\{R\}$, k : $\mathbb\{R\}$, c : $\mathbb\{R\}$, F: $\mathbb\{R\}$, $x_i: \mathbb\{R\}$, $dx_i: \mathbb\{R\}$, 
                       $(t_i, t_f)$: $\mathbb\{R\}^2$, dt: $\mathbb\{R\}$)
  N = (t$_f$ - t$_i$)/dt
  x = zeros(N+1), dx = zeros(N+1)
  x[0] = $x_i$, dx[0] = $dx_i$
  for i = 1:N+1
    x[i] = x[i-1] + dx[i-1]*dt
    dx[i] = dx[i-1] + (-k/m*x[i-1] - c/m*dx[i-1] + F/m)*dt
  x, dx

```

Now let's try again using Runge-Kutta. The implementation is only a
little more complicated

``` \{.python language="python"\}
def mass_damped_system(m : $\mathbb\{R\}$, k : $\mathbb\{R\}$, c : $\mathbb\{R\}$, F : $\mathbb\{R\}$, $x_i$, $dx_i$, 
                       $(t_i, tf)$: $\mathbb\{R\}^2$, dt: $\mathbb\{R\}$)
  N = (t$_f$ - t$_i$)/dt
  x = zeros(N+1), dx = zeros(N+1)
  x[0] = $x_i$, dx[0] = $dx_i$
  for i = 1:N+1
    k11 = dx[i-1]
    k12 = -k/m*x[i-1] - c/m*dx[i-1] + F/m
    x_mid =  x[i-1] + dt/2*(k11)
    dx_mid =  dx[i-1] + dt/2*(k12)
    k21 = dx_mid
    k22 = -k/m*x_mid  - c/m*dx_mid + F/m
    x_mid =  x[i-1] + dt/2*(k21)
    dx_mid =  dx[i-1] + dt/2*(k22)
    k31 = dx_mid
    k32 = -k/m*x_mid  - c/m*dx_mid + F/m
    x_mid =  x[i-1] + dt*(k31)
    dx_mid =  dx[i-1] + dt*(k32)
    k41 = dx_mid
    k42 = -k/m*x_mid - c/m*dx_mid + F/m
    x[i] = x[i-1] + dt*(k11 + 2*k21 + 2*k31 + k41)/6
    dx[i] = dx[i-1] + dt*(k12 + 2*k22 + 2*k32 + k42)/6
  x, dx
```

## The Lotka-Volterra Equations

The *Lotka--Volterra* equations, also known as the predator--prey
equations, are a pair of first-order, nonlinear, differential equations
frequently used to describe the dynamics of biological systems in which
two species interact, one as a predator and the other as prey. The
populations change through time according to the pair of equations:
$$\begin\{aligned\}
\frac\{dx\}\{dt\} &= ax-bxy\\
\frac\{dy\}\{dt\} &= -cy+dxy
\end\{aligned\}$$ where $x$ and $y$ are the number of prey and predators,
respectively, $a$ is the prey growth rate, $c$ is the predator death
rate, and $b$ and $d$ are the rates characterizing the effect of the
predator-prey interactions on the prey death and the predator growth,
respectively. The multiplicative terms (i.e., those involving xy) are
what make such equations nonlinear.

Let's solve the above system of equations using Euler's and Runge-Kutta
methods. First let's look at the implementation with Euler's equation

``` \{.python language="python"\}
def lotka_volterra(a: $\mathbb\{R\}$, b: $\mathbb\{R\}$, c: $\mathbb\{R\}$, d: $\mathbb\{R\}$,
                   x$_i$: $\mathbb\{R\}$, y$_i$ : $\mathbb\{R\}$, $(t_i, t_f): \mathbb\{R\}^2$, dt: $\mathbb\{R\}$):
  N = (t$_f$-t$_i$)/dt
  x = zeros(N+1), y = zeros(N+1)
  x[0] = x$_i$, y[0] = y$_i$
  for i = 1:n+1:
    x[i] = x[i-1] + (a*x[i-1] - b*x[i-1]*y[i-1])*dt
    y[i] = y[i-1] + (-c*y[i-1] + d*x[i-1]*y[i-1])*dt
  x, y
```

Now let's try again using Runge-Kutta

``` \{.python language="python"\}
def lotka_volterra(a: $\mathbb\{R\}$, b: $\mathbb\{R\}$, c: $\mathbb\{R\}$, d: $\mathbb\{R\}$,
                   x$_i$: $\mathbb\{R\}$, y$_i$: $\mathbb\{R\}$, $(t_i, t_f): \mathbb\{R\}^2$, dt: $\mathbb\{R\}$): 
  N = (t$_f$-t$_i$)/dt
  x = zeros(N+1), y = zeros(N+1)
  x[0] = x$_i$, y[0] = y$_i$
  for i = 1:n+1:
    k1x = a*x[i-1] - b*x[i-1]*y[i-1]
    k1y = -c*y[i-1] + d*x[i-1]*y[i-1]
    x_13 =  x[i-1] + dt/3*(k1x)
    y_13 =  y[i-1] + dt/3*(k1y)
    k2x = a*x_13 - b*x_13*y_13
    k2y = -c*y_13 + d*x_13*y_13
    x_23 =  x[i-1] - 1*dt/3*(k1x) + dt*(k2x)
    y_23 =  y[i-1] - 1*dt/3*(k1y) + dt*(k2y)
    k3x = a*x_23 - b*x_23*y_23
    k3y = -c*y_23 + d*x_23*y_23
    x_h =  x[i-1] + dt*(k1x-k2x+k3x)
    y_h =  y[i-1] + dt*(k1y-k2y+k3y)
    k4x = a*x_h - b*x_h*y_h
    k4y = -c*y_h + d*x_h*y_h
    x[i] = x[i-1] + dt*(k1x + 3*k2x + 3*k3x + k4x)/8
    y[i] = y[i-1] + dt*(k1y + 3*k2y + 3*k3y + k4y)/8
  x, y
```

::: marginfigure
![image](figures/part1b/ode_systems/predator_prey.png)\{width="2.75in"\}
:::

The results obtained from the Euler's and Runge-kutta methods are shown.
The time series of Euler's method indicates that the amplitudes of the
oscillations are expanding. These results indicate that the crude Euler
method would require a much smaller time step to obtain accurate
results.

In contrast, because of its much smaller truncation error, the fourth
order Runge-Kutta method yields good results with the same time step.
The same time series of Runge-Kutta's method portrays a cyclical pattern
emerging in time. Because the predator population is initially small,
the prey grows exponentially. At a certain point, the prey become so
numerous that the predator population begins to grow. Eventually, the
increased predators cause the prey to decline. This decrease, in turn,
leads to a decrease of the predators. Eventually, the process repeats.
Notice that, as expected, the predator peak lags the prey. Also, observe
that the process has a fixed period - that is, it repeats in a set time.
The phase-plane representation for the accurate RK4 solution indicates
that the interaction between the predator and the prey amounts to a
closed counterclockwise orbit.
