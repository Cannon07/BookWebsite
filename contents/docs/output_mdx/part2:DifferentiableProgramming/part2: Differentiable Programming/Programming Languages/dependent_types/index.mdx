# Dependent Types \{#chap:dependent_types\}

------------------------------------------------------------------------

\
**Prerequisites:**
[\[chap:type_theory\]](#chap:type_theory)\{reference-type="ref+label"
reference="chap:type_theory"\},
[\[chap:grad_descent\]](#chap:grad_descent)\{reference-type="ref+label"
reference="chap:grad_descent"\}\
**Difficulty Level:** \*\*\

------------------------------------------------------------------------

Broadly speaking, dependent types allow for the output type of a
function to depend on its input type. We find dependent types most
useful when presenting the types of tensor operations. For example, the
type of a matrix multiplication is naturally represented as a dependent
type.

``` \{.python language="python"\}
def matmul(A: $\mathbb\{R\}$[n, m], B: $\mathbb\{R\}$[m, o]) $\to$ $\mathbb\{R\}$[n, o]:
  C: $\mathbb\{R\}$[n, o] = 0
  for i j k:
    C[i, j] += A[i,k]*B[k, j]
  return C
```

The major advantage of dependent types for differentiable programs is
that it becomes possible to check whether complex deep networks with
sequences of array operations are well defined directly from the
associated type operations.

More generally, dependent types blur the line between expressions and
types. Any expression in a programming language can be used as a type.
This richness of types enables dependent programming languages to encode
rich programmatic invariants for their programs.

## Value Dependent Types

Constructing a fully dependent type theory for a programming language
brings with it considerable challenges. For this reason, differentiable
languages sometimes choose instead to construct a \"value dependent type
theory.\" Such a system draws a difference between values and
expressions, where a value is the fully reduced form of an expression.
In a value dependent type theory, any value can become a type but not
every expression.

### Unification

Performing type inference in a dependent programming language is
considerably trickier than performing type inference for a
Hindley-Milner language. Type inference for a value-dependent type
theory can be implemented with a variant of Haskell's standard type
inference algorithm. In general, performing full type-inference requires
programmers to sometimes add type annotations to functions. Since adding
type annotations to functional programs typically serves as
documentation, this restriction does not prove restrictive in practice.

## Full Dependent Type Theory

In Physika, we rely on the ability to represent complex mathematical
objects like $L^2(\mathbb\{R\}^3)$ as types. Constructing such types
rigorously requires full dependent type theory with its ability to prove
theorems. At the time of writing, it remains an open problem to
construct a dependent, differentiable programming language. The
construction of such a language will prove a milestone on the pathway to
constructing rigorous models of physical reality.

A critical challenge will be to provide for efficient implementations of
sophisticated, possibly infinite mathematical objects. Considerable
additional research will be needed to enable rigorous and efficient
manipulation of mathematical structures within a differentiable
programming language.
