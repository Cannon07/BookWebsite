# Spherical Convolutions \{#chap:spherical_cnn\}

------------------------------------------------------------------------

\
**Prerequisites:**
[\[chap:convnets\]](#chap:convnets)\{reference-type="ref+label"
reference="chap:convnets"\}\
**Difficulty Level:** \*\*\*\

------------------------------------------------------------------------

Equivariant representations hold out the promise of reducing sample and
model complexity and allowing for the construction of more generalizable
deep architectures. Spherical convolutional networks are constructed to
be $SO(3)$-equivariant. There are two common variants of spherical
convolutional networks. The first variant maps input quantities onto
$SO(3)$, and applies convolutions directly on the group. The second
directly performs convolutions upon the sphere. In this chapter, we
introduce this first variant of convoluion.

## A Refresher on Group Representations

Computing group convolutions can get tricky. Recall that a group
representation is a map $$\begin\{aligned\}
    \rho: G \mapsto \mathrm\{GL\}(V)
\end\{aligned\}$$ For example consider the circle, represented as a the
group of angles $e^\{i\theta\}$ in the complex sphere. We can represent
this group on $GL(\mathbb\{R\}^2)$ through the transformation
$$\begin\{aligned\}
    \rho(e^\{i\theta\}) &= \begin\{pmatrix\}
    \cos \theta & \sin \theta \\
    -\sin \theta & \cos \theta\\
    \end\{pmatrix\}
\end\{aligned\}$$ It is possible to compute a Fourier transformation on
the circle $$\begin\{aligned\}
    \hat\{f\}(m) &= \frac\{1\}\{2\pi\} \int_\{-\pi\}^\{\pi\}f(\theta) e^\{-im\theta\}d \theta \\
    f(\theta) &= \sum_\{m\} e^\{im\theta\} f(\theta)
\end\{aligned\}$$ More generally, there exists a convolution operation on
groups $$\begin\{aligned\}
    \widehat\{(f\star k)(\theta)\} &= \hat\{f\}(\theta)\hat\{k\}(\theta)
\end\{aligned\}$$ We can use the general formula for a group convolution
below and apply it to obtain $SO(3)$ group convolutions
$$\begin\{aligned\}
    f*k &= \int_\{g\in SO(3)\}f(gv)k(g^\{-1\}v) dg. 
\end\{aligned\}$$ $v$ is typically chosen to be some canonical element in
the domain of $f$. For three dimensional spherical convolutions, $v$ can
be chosen to be the north pole of the sphere. In practice this integral
cannot be computed exactly, but it can be numerically approximated. To
implement this approximation, we have to sample points on the surface of
the sphere (we can index an arbitrary transformation in $SO(3)$ by the
position that it maps the north pole reference point).

A simple strategy to do this may be to sample at constant latitudes and
longitudes. Another strategy would be to draw uniformly random points on
the sphere. However, either such sampling creates non-uniform cells on
the sphere which worsens numerical estimates. A better strategy will
instead be to take the Fourier transform and perform the convolution in
Fourier space. On the sphere, we can compute the Fourier transform by
using spherical harmonics $$\begin\{aligned\}
\hat\{f\}^\ell_m &= \int_\{S^2\} f(x) \overline\{Y^\ell_m\} dx \\
f &= \sum_\{0 \leq \ell \leq b\} \sum_\{|m| \leq b\} \hat\{f\}^\{\ell\}_m Y^\ell_m \\
\end\{aligned\}$$

Here $b$ is a quantity referred to as the bandwidth of the signal $f$
and is the number of nonzero Fourier modes. $Y^\ell_m$ are spherical
harmonics. These two transformations are respectively referred to as the
spherical fourier transform and its inverse.

The integral for the Fourier transform can't be computed exactly, but it
can be numerically approximated by drawing equiangular samples on the
sphere $S^2$. Computing this numerical sum can still be quite expensive.
Once the transformation is performed, the group convolution can then be
computed by direct multiplication in the Fourier space by the spherical
convolution theorem

$$\begin\{aligned\}
\hat\{(f*k)\}_m &= 2 \pi \sqrt\{\frac\{4 \pi\}\{2 \ell + 1\}\} \hat\{f\}^\ell_m \hat\{h\}^\ell_m
\end\{aligned\}$$

The inverse spherical Fourier transform can then be used to recover the
signal $f*k$.

## Implementing the Spherical Convolution

The spherical Fourier is implemented in practice using equiangular
samples on the sphere.

$$\begin\{aligned\}
\hat\{f\}^\ell_m &= \frac\{\sqrt\{2 \pi\}\}\{2b\} \sum_\{j=0\}^\{2b-1\} \sum_\{k=0\}^\{2b-1\} a^\{(b)\}_j f(\theta_j, \phi_k) \overline\{Y^\ell_m\}(\theta_j, \phi_k)
\end\{aligned\}$$ Here the $\theta_j, \phi_k$ are equiangular sample
points $$\begin\{aligned\}
    \theta_j &= \frac\{\pi j\}\{2 b\} \\
    \phi_k &= \frac\{\pi k\}\{b\},
\end\{aligned\}$$

The values $\overline\{Y^\ell_m\}$ are precomputed at these points. The
$a^\{(b)\}_j$ are sample weights. This formula can be directly implemented
in a differentiable programming language.

We can implement the spherical convolution using the spherical fourier
transform as a primitive.

``` \{.python language="python"\}
class SphericalConvolution(w: $\mathbb\{R\}[|m]$):
  def $\lambda$(X: $\mathbb\{R\}[m]$) -> $\mathbb\{R\}[|G|]$:
    X$'$ = SphericalFourierTransform(X)
    w$'$ = SphericalFourierTransform(w)
    return InverseSphericalFourierTransform($2 \pi \sqrt\{\frac\{4 \pi\}\{2 \ell + 1\}\}$ X$'$ * w$'$)
```

The spherical fourier transform itself can be implemented using the
equiangular sampling we have just introduced.
