# Physika Primer \{#chap:physika\}

------------------------------------------------------------------------

\
**Prerequisites:**
[\[chap:math_basics\]](#chap:math_basics)\{reference-type="ref+label"
reference="chap:math_basics"\}\
**Difficulty Level:** \*\

------------------------------------------------------------------------

Throughout this book, we use pseudocode to represent various
differentiable programs of interest. We code our pseudocode in a
language called Physika (greek for physics). Physika is a fully
differentiable, dependently typed language. This combination of features
allows Physika to model physical theories succinctly and effectively. In
this chapter we provide a brief introduction to Physika.

## An Introduction to Physika by Example

Much of Physika's syntax follows that of Python. For example, here's how
you define a function that adds two numbers.

``` \{.python language="python"\}
# This is a comment.
def add(x: $\mathbb\{R\}$, y: $\mathbb\{R\}$) $\to$ $\mathbb\{R\}$:
  x + y
```

Notice that we don't define an explicit return type. Physika follows the
convention that the last expression in a function is its return value.
This allows for simple mathematically crisp definitions.

Physika is a typed language with a rich and descriptive type system for
annotating function inputs and outputs. We allow variables to have type
$\mathbb\{R\}$. We can't directly represent infinite decimal place real
numbers on an actual computer. But we can symbolically manipulate values
in $\mathbb\{R\}$. We can also specialize this function to operate on a
subset of $\mathbb\{R\}$ like the 32 bit floating point numbers
$\textrm\{Float32\}$. In practice, it will be clear how to specialize a
function that operates on the real numbers to a computationally
realizable version, but if there are subtleties we will mention them
with examples.

We define the type of an array as

``` \{.python language="python"\}
x : $\mathbb\{R\}$[n]
```

Multidimensional arrays are defined similarly

``` \{.python language="python"\}
y : $\mathbb\{R\}$[n, m, o]
```

The type of a tensor is similar to the type for a multidimensional
array, with a crucial difference that covariant and contravariant
indices must be annotated in the type.

``` \{.python language="python"\}
z : $\mathbb\{R\}$[+n, +m, -o]
```

In mathematical tensor notation we would write this as something like
$z^\{\alpha \beta\}_\{\gamma\}$. Note that tensor $z$ is not the same as a
multidimensional array since it depends on a choice of basis. It is
possible to *cast* a tensor object into a multidimensional array. The
default cast will use the current basis of the tensor object.

Physika is dependently typed. What does that mean? To start, it means
that the following function is valid.

``` \{.python language="python"\}
def append(x: a, xs: a[n]) $\to$ a[n+1]:
  xs + [x]
```

Note that the type is a free variable. This is typically referred to as
parameteric polymorphism in the programming language literature. You can
think about as a placeholder that can be replaced with any other type
like $\mathbb\{R\}$ or . Another interesting property of this definition
is that the return type can depend on the provided arguments.

Let's now see how we can define a variable with a value

``` \{.python language="python"\}
x : $\mathbb\{R\}$ = 5.12
```

Next, we consider a more complex example of matrix multiplication. Here
is how we would code a matrix multiplication algorithm in Physika

``` \{.python language="python"\}
def matmul(A: $\mathbb\{R\}$[n, m], B: $\mathbb\{R\}$[m, o]) $\to$ $\mathbb\{R\}$[n, o]:
  C: $\mathbb\{R\}$[n, o] = 0
  for i j k:
    C[i, j] += A[i,k]*B[k, j]
  C
```

We use the type system to infer that `i` and `j` above must respectively
take values in `[0,...,n-1]` and `[0,...,o-1]`. Type inference allows us
to make compact readable code for numerical applications. We can use
type inference to simplify operations like Einstein summation. For
example, an expression like $$\begin\{aligned\}
    T^\{\alpha\}_\beta v^\{\beta\} 
\end\{aligned\}$$ which represents a matrix vector multiplication can be
represented as a code snippet

``` \{.python language="python"\}
T: $\mathbb\{R\}$[$+n$, $-m$]
v: $\mathbb\{R\}$[$+m$]
sum(for $\beta$ T[$\alpha$, $\beta$] * v[$\beta$])
```

We can also rely on Physika to do type inference on tensor shapes and
covariances properly.

``` \{.python language="python"\}
T: $\mathbb\{R\}$[+m, +n, -o]
U: $\mathbb\{R\}$[+o]
T[+$\alpha$, +$\beta$, -$\gamma$]U[$+\gamma$]: $\mathbb\{R\}$[$+\alpha$, $+\beta$]
```

Physika is a differentiable programming language, so differentiation
operators are first class in the language. Phyika has two
differentiation operators for forward and backwards mode differentiation

    T # Tangent Operator for forward mode
    $\nabla$ # Gradient Operator for backwards mode
    $\frac\{d\}\{dt\}$ # Alternative syntax for backwards mode

We now explore a slightly more complicated example using Physika to
encode some simple motion of particles. We can encode

``` \{.python language="python"\}
x: $\mathbb\{R\}$ $\to$ $\mathbb\{R\}^3$
x(t) = (t, t, t)
v = $\frac\{dx\}\{dt\}$
```

What is the type of $v$? We write

``` \{.python language="python"\}
v: $\mathbb\{R\}$ $\to$ $T \mathbb\{R\}^3$
```

Let's write down a type for the differentiation operator in this
particular case.

``` \{.python language="python"\}
$\frac\{d\}\{dt\}$: ($\mathbb\{R\}$ $\to$ $\mathbb\{R\}^3$) $\to$ $T \mathbb\{R\}^3$
```

Physika is capable of expressing more complex function spaces. Notably,
we will make use of $L^2$ function space types for representing wave
functions.

``` \{.python language="python"\}
$\psi$: $L^2[\mathbb\{R\}^3, \mathbb\{C\}]$
```

The study of quantum mechanics encompasses not only the study of wave
functions but of operators that act on them. For example, consider the
momentum operator that acts on wave functions. This operator has type

``` \{.python language="python"\}
$\hat\{p\}$: $L^2[\mathbb\{R\}^3]$ $\to$ $L^2[\mathbb\{R\}^3]$
```

We could try to write this type as

``` \{.python language="python"\}
$\hat\{p\}$: $\mathcal\{B\}(L^2[\mathbb\{R\}^3])$
```

This model is wrong, since $\hat\{p\}$ is not necessarily bounded as an
operator, but serves to show how Physika can represent the type of
bounded operators on Hilbert space. We can represent common quantum
mechanical operations such as bras, kets, and brakets with suitable
types.

``` \{.python language="python"\}
$|\psi(x)\rangle$ $\equiv$ $\psi: L^2[\mathbb\{R\}^3, \mathbb\{C\}]$
```

The type of a quantum mechanical bra is given by

``` \{.python language="python"\}
$\langle \psi(x)|$ $\equiv$ $L^2[\mathbb\{R\}^3, \mathbb\{C\}] \to \mathbb\{C\}$
```

We can represent yet more complicated spaces. For example, to compute
with path integrals, we need to represent the type of all evolution
paths for a given quantum mechanical system.

``` \{.python language="python"\}
p: [0, 1] $\to$ $L^2(\mathbb\{R\}^3)$
```

## Symbolic Manipulation

For describing certain algorithms, it will be useful to perform symbolic
manipulations.

``` \{.python language="python"\}
x: Symbol
x$^4$ - 3x$^2$ + 13
```

Symbolic variables can be used to express and manipulate formulas.

## Parameterized Functions

Layers in deep networks are typically represented as parameterized
functions $f_\theta$. A parameterized function can be viewed as a family
of concrete functions $$\begin\{aligned\}
    \{ f_\{\theta\} | \theta \in \Theta \}
\end\{aligned\}$$

We write a parameterized layer function in Physika by using the `class`
keyword.

``` \{.python language="python"\}
class Layer(param$_1$: T$_1$,$\dotsc$):
  def $\lambda$(arg$_1$: A$_1$,$\dotsc$): R_1
    ...
```

We use the notation $\lambda$ to denote the function call to the
parameterized function. The parameters of the function are set in the
constructor. We can define a simple weighted linear layer using a
parameterized function as follows

``` \{.python language="python"\}
# Weighted Addition
class F($w_1$: $\mathbb\{R\}$, $w_2$: $\mathbb\{R\}$):
  def $\lambda$(x: $\mathbb\{R\}$, y: $\mathbb\{R\}$): $\mathbb\{R\}$:
    $w_1$ * x + $w_2$ * y
```

We can express the type of a parameterized function in a type signature
as

$$\begin\{aligned\}
    (\textrm\{Input Types\}\ \to \ \textrm\{Output Types\})[\textrm\{Parameter Types\}]
\end\{aligned\}$$

For the particular case of the simple weighted linear layer, we would
express this signature as

$$\begin\{aligned\}
(\mathbb\{R\}\times\mathbb\{R\}\to\mathbb\{R\})[\mathbb\{R\}, \mathbb\{R\}]
\end\{aligned\}$$

## Standard Library

Physika features a standard library of mathematical functions that
should be familiar from other programming environments

``` \{.python language="python"\}
abs, max, min, uniform, zeros
```
