# Grammars \{#chap:grammar\}

------------------------------------------------------------------------

\
**Prerequisites:** High School Level Mathematics\
**Difficulty Level:** \*\

------------------------------------------------------------------------

Over the next several chapters, we will introduce the foundations of
programming language theory and build up to an explanation of how
Physika works. We start with basics: the syntax of a programming
language is given by a grammar, a set of rules for expanding out terms
of a language. In this chapter, we introduce the basics of grammars.

## Backus-Naur Form

Backus-Naur Form (BNF) provides a mechanism to define how a programming
language is defined. The simple grammar below defines the syntax for a
very simple programming language with arithmetic. $$\begin\{aligned\}
    e ::= & c  \\
    &| e + e \\
    &| e - e \\
    &| e * e \\
    &| e / e \\
    c ::= & digit | nonzero\ c \\
    digit ::= & 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 \\
    nonzero ::=  & 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
\end\{aligned\}$$ This layout should be read as a form of combinatorial
expansion. Valid examples of strings in this language would be

    3, 3 + 4, 3 + 4 + 5, 4 + 5 / 6

Note how the symbolic form of the BNF governs the type of expressions
that can be formed. In later chapters, we will use use BNF to define
more complicated programming languages.

## Lexers and Parsers

Although this book isn't focused on the practical computer science and
engineering considerations needed to implement a language, we note
briefly that to implement a simple language we would need to define a
lexer which transforms input text into tokens, and a parser, which
assembles these tokens into an abstract syntax tree. There are a number
of packages available which convert a given Backus-Naur form into a
lexer/parser that can be used for language implementation.

If you would like to learn more about these methods, we recommend
referring to a standard compilers textbook.

## Exercises

1.  The simple language defined above doesn't handle operator ordering
    correctly. For example, you cannot write the equivalent of the
    fraction $$\begin\{aligned\}
            \frac\{3+4\}\{5+6\}
        
    \end\{aligned\}$$ Define a Backus-Naur Form grammar for a language
    with correct operator handling for arithmetic expressions.
