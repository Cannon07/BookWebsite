# Semantics of Programming Languages \{#chap:transformer\}

------------------------------------------------------------------------

\
**Prerequisites:**
[\[chap:type_theory\]](#chap:type_theory)\{reference-type="ref+label"
reference="chap:type_theory"\},
[\[chap:grad_descent\]](#chap:grad_descent)\{reference-type="ref+label"
reference="chap:grad_descent"\}\
**Difficulty Level:** \*\*\

------------------------------------------------------------------------

Semantics attempts to assign rigorous mathematical meanings to computer
programs. Given a syntactically valid string in a programming language,
a semantic model assigns to it a mathematical object that represents the
the given computation. (Invalid strings are assigned to a suitable no-op
object.)

Operational and denotational semantics are two common methods of
assigning meaning to programs. Operational semantics directly describes
the execution of language operations mathematically, while denotational
semantics maps program constructs to abstract mathematical objects.

## Operational Semantics

Operational semantics transforms language operations into algorithmic
instructions for a virtual machine. Operational semantics roughly
presents a pseudocode implementation for an underlying interpreter.
Operational semantics are typically broken into the two additional
categories of small-step and big-step operational semantics. Small-step
semantics provide a tight-grained update which directly considers
updates to the underlying memory of the system. For example, here is a
small-step semantics rule for sequential evaluation of a program.

$$\begin\{aligned\}
\{2\}
    &\inference[]
    \{
     \langle C, s \rangle \Rightarrow s'
    \}
    \{
    \langle C; D, s \rangle \Rightarrow \langle D, s' \rangle 
    \} \ \textrm\{[Sequential]\} 
\end\{aligned\}$$

Here $C$, $D$ are programs and $s$, $s'$ represents memory states of an
underlying virtual machine. The above expression corresponds to the
statement \"If running program $C$ starting in memory state $s$ results
in memory state $s'$, then running programs $C$ and $D$ in sequence has
the same result as running program $D$ starting from memory state
$s'$.\"

Small step semantics typically provide the semantics for low level
machine operations. This can become tedious for larger programs, so many
papers often consider big step semantics, which attempts to directly
provide meanings for higher order operations. For example, consider

$$\begin\{aligned\}
\{2\}
    &\inference[]
    \{
     \langle a_1, s \rangle \Rightarrow i_1, \quad \langle a_2, s \rangle \Rightarrow i_2
    \}
    \{
    \langle a_1 + a_2, s \rangle \Rightarrow i_1 + i_2 
    \} \ \textrm\{[Sequential]\} 
\end\{aligned\}$$ Here $a_1$, $a_2$ are arithmetic expressions. This
statement can be read as \"If $a_1$ is an arithmetic expression which
evaluates to $i_1$ and $a_2$ is an arithmetic expression which evaluates
to $i_2$ then $a_1 + a_2$ evaluates to $i_1 + i_2$.

## Denotational Semantics

Denotational semantics provide a mathematical mechanism of transforming
a function from standard types into mathematical objects. For example,
suppose that `R` is the type of real numbers and $\mathbb\{R\}$ is the
real numbers. We may say

$$\begin\{aligned\}
    x \in R \mapsto \llbracket x \rrbracket \in \mathbb\{R\}
\end\{aligned\}$$ to capture how a variable of type `r` is mapped to its
corresponding real number value. Intuitively, the denotational semantics
of our Physika programs must match the underlying mathematical
definitions of the functions involved.

## Exercises

1.  Construct an operational semantics for the Lambda calculus.

2.  Construct a denotational semantics for the Lambda calculus.
