# Integral Programming \{#ch:integralprog\}

------------------------------------------------------------------------

\
**Prerequisites:**
[\[chap:ml_basics\]](#chap:ml_basics)\{reference-type="ref+label"
reference="chap:ml_basics"\}\
**Difficulty Level:** \*\*\

------------------------------------------------------------------------

Integral programs are differentiable programs which include integration
as a construct. Many physical equations naturally feature integrals in
their descriptions, making the ability to manipulate integrals within a
differentiable program a powerful advantage. Let's start with a simple
mathematical example. Assume that we want to learn a function $f$ with
the form

$$\begin\{aligned\}
 f(x) = \int_0^x g(y, \theta) dy 
\end\{aligned\}$$

Here $\theta$ is a learnable parameter, $f$ is the function we'd like to
learn and $g$ is its derivative. This general pattern arises often in
physics, when we seek the solution to a set of differential equations.
How can we optimize this function? Suppose that we have a dataset with
training data points $X$ and labels $y$

$$\begin\{aligned\}
    X &= x_1,\dotsc, x_n \\
    y &= y_1, \dotsc, y_n
\end\{aligned\}$$

Assume that we're performing a regression task with $L^2$ loss. The
learning task then is

$$\begin\{aligned\}
    \arg\min_\{\theta\} \sum_\{i=1\}^N \left \| \int_0^\{x_i\} g(y, \theta) dy - y_i\right \|^2
\end\{aligned\}$$

Differentiating the loss $\mathcal\{L\}$ through the integral sign, we'll
be left with a term that looks like

$$\begin\{aligned\}
\nabla \mathcal\{L\} \approx \int_0^x \frac\{\partial\}\{ \partial \theta\} g(y, \theta) dy 
\end\{aligned\}$$

Integrating arbitrary functions can be extremely challenging and is not
possible to do in general except numerically. So, we fall back to some
type of numerical solver. Assume that we have an algorithm
$\textrm\{Integrate\}$ that implements a numerical solver. That is

$$\begin\{aligned\}
\int_0^x g(y, \theta) dy \approx \textrm\{Integrate\}(g, x, \theta) 
\end\{aligned\}$$

Then we can rewrite our learning task as

$$\begin\{aligned\}
    \arg\min_\{\theta\} \sum_\{i=1\}^N \| \textrm\{Integrate\}(g, x_i, \theta) - y_i\|^2
\end\{aligned\}$$

If $\textrm\{Integrate\}$ is a standard numerical integration scheme, it
is easy to show that $\textrm\{Integrate\}$ is a differentiable function.
This means that every term in the loss equation above is differentiable.
We have succeeded in reducing an integral program into a differentiable
program.

In practice, the choice of integration scheme for $\textrm\{Integrate\}$
will be critical. The example we covered above is 1-dimensional, but in
practice, the integral program we seek to solve might involve a set of
high dimensional differential equations. More sophisticated Monte Carlo
integration schemes are required to solve such integrals.

## Physical Examples

We consider a few examples of integral programs in modeling physical
systems.

### Variational Problems

Integral programs naturally lend themselves to solving variational
problems which arise in physics. For example, consider the
Euler-Lagrange equation

$$\begin\{aligned\}
    S[q] &= \int_\{x_1\}^\{x_2\} L(x, q(x), q'(x)) dx
\end\{aligned\}$$

Here $S$ is a quantity commonly known as the action functional and $L$
is the Lagrangian. The minima of the action functional provides the
equations of motion for a physical system. We can formulate the action
function as an integral program

``` \{.python language="python"\}
def S(q: [$x_1$, $x_2$] $\to$ $\mathbb\{R\}$) $\to$ $\mathbb\{R\}$:
  return Integrate(q, $x_1$, $x_2$, L(x, q, $\frac\{d\}\{dt\}$(q))
```

This differentiable program can be optimized directly by choosing a
suitable parameterized form of `q` (perhaps as a fully connected
network).

### Path Integral Programming

One of the most powerful tools of mathematical physics which we will
develop in this book is the path integral. Path integral calculations
are fundamental to modern quantum mechanics and modern quantum field
theory. In this section, we will introduce some of their mathematical
foundations and explain how we can use path integrals in integral
programs. The foundation for path integral calculations is evaluation of
Gaussian integrals so we will start by considering some Gaussian
integrals. These integrals will be of considerable interest when we
return to quantum field theory later in this book.

### Gaussian Integrals

Let's now consider a very simple integral program

``` \{.python language="python"\}
def gaussian_integral(a: $\mathbb\{R\}$, J: $\mathbb\{R\}$):
  return $\int_\{-\infty\}^\{\infty\}$ exp(-$\frac\{1\}\{2\}$a*x$^2$ + J*x)
```

We can have Physika numerically evaluate this integral. This integral
also has a direct value which can be computed by completing the square
so the numerical evaluation isn't useful in practice.

We can perturb this integral to consider $$\begin\{aligned\}
 G = \int_\{-\infty\}^\{\infty\} e^\{-\frac\{1\}\{2\}ax^2 + iJ x\} dx 
\end\{aligned\}$$

where $i$ is the imaginary number. Our strategy of completing the square
works here so we can simply plug into a standard formula and obtain.

$$\begin\{aligned\}
 G = \sqrt\{\frac\{2 \pi\}\{a\}\} e^\{(iJ)^2/2a\} = \sqrt\{\frac\{2 \pi\}\{a\}\} e^\{-J^2/2a\} 
\end\{aligned\}$$

Here's one more variant with $a$ replaced by $-ia$

$$\begin\{aligned\}
 \int_\{-\infty\}^\{\infty\} e^\{\frac\{1\}\{2\}iax^2 + iJx\} dx 
\end\{aligned\}$$

Let's again plug into the formula we derived above.

$$\begin\{aligned\}
 G = \sqrt\{\frac\{2 \pi\}\{-ia\}\} e^\{(iJ)^2/(-2ia)\} = \sqrt\{\frac\{2 \pi i\}\{a\}\} e^\{-iJ^2/2a\} 
\end\{aligned\}$$

What happens though when the integral we consider becomes non-Gaussian?

$$\begin\{aligned\}
 H = \int_\{-\infty\}^\{\infty\} e^\{-\frac\{1\}\{2\}ax^2 + b x^4\} dx 
\end\{aligned\}$$ An integral program can be defined as

``` \{.python language="python"\}
def nongaussian_integral(a: $\mathbb\{R\}$, J: $\mathbb\{R\}$):
  return $\int_\{-\infty\}^\{\infty\}$ exp(-$\frac\{1\}\{2\}$a*x$^2$ + J*x$^4$)
```

and evaluated numerically. Techniques from perturbation theory can be
used to perform approximations in a structured fashion which we can
encode into algorithmic solvers.
